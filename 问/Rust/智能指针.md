TAGS:具体的问题|智能指针|ownership|borrowing|reference

built-in type就是能放在寄存器和栈上使用的类型
- int
- float

[Smart pointers](https://doc.rust-lang.org/book/second-edition/ch15-00-smart-pointers.html)

> A pointer is a general concept for a variable that contains an address in memory

> reference don’t have any special abilities other than referring to data.They also don’t have any overhead, so they’re used the most often.

通常指针在栈上指向堆内存,指针(显式或隐式调用)用于方法调用.一般来说最好由编译器或虚拟机来管理,reference.用户概念上认为两者等价即可,不需要感知到指针的存在.因此也不要对reference做指针运算.

> Smart pointers, on the other hand, are **data structures** that act like a pointer, but they also have additional **metadata** and **capabilities**

>  the reference counting smart pointer type enables you to have **multiple owners** of data.

> The reference counting smart pointer keeps track of how many owners there are, and when there aren’t any remaining, the smart pointer takes care of cleaning up the data

智能指针与所有权有关
所有权可以概括为对内存的权限
- 读
- 写

> In Rust, where we have the concept of ownership and borrowing, an additional difference between references and smart pointers is that **references are a kind of pointer that only borrow data**; by contrast, in many cases, **smart pointers own the data that they point to**.

引用的传递是借用,借用的权限传递规则是?

> We’ve actually already encountered a few smart pointers in this book, such as **String and Vec<T>**

所有proxy class都可以看作指针,不完全拥有所有成员字段的所有权的对象?

> Smart pointers are usually implemented using structs. The characteristics that distinguish a smart pointer from an ordinary struct are that smart pointers implement the **Deref** and **Drop** traits. The Deref trait allows an instance of the smart pointer struct to **behave like a reference** so that we can write code that works with either references or smart pointers. The Drop trait allows us to **customize the code** that gets run when an instance of the smart pointer goes out of scope. 

